/*
 * test_filesystem_support.cpp - Test filesystem::path serialization
 * 
 * Generated by Claude UI to test filesystem path support
 */

#include "meta_yaml.h"
#include <iostream>
#include <cassert>

struct FileConfig {
    std::string name;
    std::filesystem::path configPath;
    std::filesystem::path dataDir;

    static constexpr auto fields = std::tuple{
        meta::Field<&FileConfig::name>{"name"},
        meta::Field<&FileConfig::configPath>{"configPath"},
        meta::Field<&FileConfig::dataDir>{"dataDir"}
    };
};

struct Project {
    std::string title;
    std::filesystem::path rootDir;
    std::vector<std::filesystem::path> sourceFiles;
    std::map<std::string, std::filesystem::path> assets;

    static constexpr auto fields = std::tuple{
        meta::Field<&Project::title>{"title"},
        meta::Field<&Project::rootDir>{"rootDir"},
        meta::Field<&Project::sourceFiles>{"sourceFiles"},
        meta::Field<&Project::assets>{"assets"}
    };
};

int main() {
    std::cout << "\n╔════════════════════════════════════════════════════════════╗" << std::endl;
    std::cout << "║  meta_yaml.h - Filesystem Path Support Tests              ║" << std::endl;
    std::cout << "╚════════════════════════════════════════════════════════════╝\n" << std::endl;

    // Test 1: Simple path serialization
    std::cout << "=== Test 1: Simple Path Serialization ===" << std::endl;
    
    FileConfig config{
        "AppConfig",
        "/etc/app/config.yaml",
        "/var/data/app"
    };
    
    std::string yaml = meta::toYaml(config);
    std::cout << "Serialized:\n" << yaml << std::endl;
    
    auto [deserialized, result] = meta::fromYaml<FileConfig>(yaml);
    assert(result.valid);
    assert(deserialized->name == "AppConfig");
    assert(deserialized->configPath == std::filesystem::path("/etc/app/config.yaml"));
    assert(deserialized->dataDir == std::filesystem::path("/var/data/app"));
    
    std::cout << "✓ Deserialized paths correctly" << std::endl;
    std::cout << "  configPath: " << deserialized->configPath << std::endl;
    std::cout << "  dataDir: " << deserialized->dataDir << std::endl;
    std::cout << std::endl;

    // Test 2: Complex structure with paths
    std::cout << "=== Test 2: Complex Structure with Paths ===" << std::endl;
    
    Project project{
        "MyProject",
        "/home/user/projects/myproject",
        {
            "/home/user/projects/myproject/src/main.cpp",
            "/home/user/projects/myproject/src/utils.cpp",
            "/home/user/projects/myproject/include/header.h"
        },
        {
            {"icon", "/home/user/projects/myproject/assets/icon.png"},
            {"logo", "/home/user/projects/myproject/assets/logo.svg"},
            {"config", "/home/user/projects/myproject/assets/config.json"}
        }
    };
    
    std::string project_yaml = meta::toYaml(project);
    std::cout << "Serialized:\n" << project_yaml << std::endl;
    
    auto [proj_deser, proj_result] = meta::fromYaml<Project>(project_yaml);
    assert(proj_result.valid);
    assert(proj_deser->title == "MyProject");
    assert(proj_deser->rootDir == std::filesystem::path("/home/user/projects/myproject"));
    assert(proj_deser->sourceFiles.size() == 3);
    assert(proj_deser->sourceFiles[0] == std::filesystem::path("/home/user/projects/myproject/src/main.cpp"));
    assert(proj_deser->assets["icon"] == std::filesystem::path("/home/user/projects/myproject/assets/icon.png"));
    
    std::cout << "✓ Complex structure deserialized correctly" << std::endl;
    std::cout << "  Title: " << proj_deser->title << std::endl;
    std::cout << "  Root: " << proj_deser->rootDir << std::endl;
    std::cout << "  Source files: " << proj_deser->sourceFiles.size() << std::endl;
    std::cout << "  Assets: " << proj_deser->assets.size() << std::endl;
    std::cout << std::endl;

    // Test 3: Path parsing from external YAML
    std::cout << "=== Test 3: Path Parsing from External YAML ===" << std::endl;
    
    std::string external_yaml = R"(
name: ExternalConfig
configPath: /etc/external/config.yaml
dataDir: /var/lib/external
)";
    
    std::cout << "Input YAML:\n" << external_yaml << std::endl;
    
    auto [ext_config, ext_result] = meta::fromYaml<FileConfig>(external_yaml);
    assert(ext_result.valid);
    assert(ext_config->configPath == std::filesystem::path("/etc/external/config.yaml"));
    
    std::cout << "✓ Successfully parsed external YAML" << std::endl;
    std::cout << "  configPath: " << ext_config->configPath << std::endl;
    std::cout << std::endl;

    // Test 4: Relative paths
    std::cout << "=== Test 4: Relative Paths ===" << std::endl;
    
    FileConfig rel_config{
        "RelativeConfig",
        "./config.yaml",
        "./data"
    };
    
    std::string rel_yaml = meta::toYaml(rel_config);
    std::cout << "Serialized:\n" << rel_yaml << std::endl;
    
    auto [rel_deser, rel_result] = meta::fromYaml<FileConfig>(rel_yaml);
    assert(rel_result.valid);
    assert(rel_deser->configPath == std::filesystem::path("./config.yaml"));
    assert(rel_deser->dataDir == std::filesystem::path("./data"));
    
    std::cout << "✓ Relative paths handled correctly\n" << std::endl;

    // Test 5: Windows-style paths (as strings, cross-platform)
    std::cout << "=== Test 5: Windows-style Paths ===" << std::endl;
    
    std::string windows_yaml = R"(
name: WindowsConfig
configPath: C:\Program Files\App\config.yaml
dataDir: D:\Data
)";
    
    std::cout << "Input YAML:\n" << windows_yaml << std::endl;
    
    auto [win_config, win_result] = meta::fromYaml<FileConfig>(windows_yaml);
    assert(win_result.valid);
    std::cout << "✓ Windows-style paths parsed as strings" << std::endl;
    std::cout << "  configPath: " << win_config->configPath << std::endl;
    std::cout << "  dataDir: " << win_config->dataDir << std::endl;
    std::cout << std::endl;

    std::cout << "╔════════════════════════════════════════════════════════════╗" << std::endl;
    std::cout << "║  ✓ ALL FILESYSTEM TESTS PASSED                             ║" << std::endl;
    std::cout << "╚════════════════════════════════════════════════════════════╝\n" << std::endl;

    return 0;
}

/*
 * meta.h - C++20 Serialization Framework
 *
 * This test file was automatically generated by Claude UI to demonstrate
 * the capabilities and features of the meta.h C++20 serialization framework.
 */

#include <concepts>
#include <iostream>
#include <map>
#include <stdexcept>
#include <string>
#include <vector>

#include "meta.h"

namespace meta
{

// ============================================================================
// CONSTRAINT CONCEPTS
// ============================================================================

template <typename C, typename T>
concept Constraint = requires(C c, T t) {
    { c.validate(t) } -> std::convertible_to<bool>;
    { c.error(t) } -> std::convertible_to<std::string>;
};

// ============================================================================
// CONSTRAINED MAP
// ============================================================================

template <typename K, typename V, typename KeyConstraint, typename ValueConstraint>
class ConstrainedMap
{
  public:
    using key_type = K;
    using mapped_type = V;
    using key_constraint_type = KeyConstraint;
    using value_constraint_type = ValueConstraint;

    ConstrainedMap(const KeyConstraint& kc = KeyConstraint{},
                   const ValueConstraint& vc = ValueConstraint{})
        : keyConstraint_(kc),
          valueConstraint_(vc)
    {
    }

    void insert(const K& key, const V& value)
    {
        if (!keyConstraint_.validate(key))
        {
            throw std::runtime_error("Key constraint violated: " + keyConstraint_.error(key));
        }
        if (!valueConstraint_.validate(value))
        {
            throw std::runtime_error("Value constraint violated: " + valueConstraint_.error(value));
        }
        data_[key] = value;
    }

    bool contains(const K& key) const
    {
        return data_.find(key) != data_.end();
    }

    V& at(const K& key)
    {
        return data_.at(key);
    }
    const V& at(const K& key) const
    {
        return data_.at(key);
    }
    V& operator[](const K& key)
    {
        return data_[key];
    }

    size_t size() const
    {
        return data_.size();
    }
    bool empty() const
    {
        return data_.empty();
    }

    auto begin()
    {
        return data_.begin();
    }
    auto end()
    {
        return data_.end();
    }
    auto begin() const
    {
        return data_.begin();
    }
    auto end() const
    {
        return data_.end();
    }

    bool operator==(const ConstrainedMap& other) const
    {
        return data_ == other.data_;
    }

    // ========================================
    // Custom deserializer with constraint validation
    // ========================================
    struct Deser
    {
        static ValidationResult parse(ConstrainedMap& obj, Node* node)
        {
            ValidationResult result;

            if (!node->isMap())
            {
                result.addError("", "Expected map");
                return result;
            }

            obj.data_.clear();
            bool hasErrors = false;

            for (const auto& key_str : node->keys())
            {
                K key = key_str;

                // Validate key constraint
                if (!obj.keyConstraint_.validate(key))
                {
                    result.addError(key_str,
                                    "Key constraint violated: " + obj.keyConstraint_.error(key));
                    hasErrors = true;
                    continue;
                }

                auto vNode = node->at(key_str);
                if (!vNode)
                {
                    result.addError(key_str, "Failed to get value node");
                    hasErrors = true;
                    continue;
                }

                V value{};
                auto vResult = from<V>(value, vNode.get());

                if (!vResult.valid)
                {
                    for (auto& [f, e] : vResult.errors)
                    {
                        result.addError(key_str + (f.empty() ? "" : "." + f), e);
                    }
                    hasErrors = true;
                    continue;
                }

                // Validate value constraint
                if (!obj.valueConstraint_.validate(value))
                {
                    result.addError(
                        key_str, "Value constraint violated: " + obj.valueConstraint_.error(value));
                    hasErrors = true;
                    continue;
                }

                obj.data_[key] = value;
            }

            result.valid = !hasErrors;
            return result;
        }
    };

    // ========================================
    // Custom serializer
    // ========================================
    struct Ser
    {
        static void write(const ConstrainedMap& obj, Builder* b)
        {
            b->startMap("");
            for (const auto& [k, v] : obj.data_)
            {
                b->key(k);
                to(v, b);
            }
            b->endMap();
        }
    };

  private:
    std::map<K, V> data_;
    KeyConstraint keyConstraint_;
    ValueConstraint valueConstraint_;
};

// ============================================================================
// CONSTRAINED VECTOR
// ============================================================================

template <typename T, typename ElementConstraint> class ConstrainedVector
{
  public:
    using element_type = T;
    using constraint_type = ElementConstraint;

    ConstrainedVector(const ElementConstraint& ec = ElementConstraint{}) : elementConstraint_(ec)
    {
    }

    void push_back(const T& value)
    {
        if (!elementConstraint_.validate(value))
        {
            throw std::runtime_error("Element constraint violated: " +
                                     elementConstraint_.error(value));
        }
        data_.push_back(value);
    }

    T& operator[](size_t index)
    {
        return data_[index];
    }
    const T& operator[](size_t index) const
    {
        return data_[index];
    }

    size_t size() const
    {
        return data_.size();
    }
    bool empty() const
    {
        return data_.empty();
    }

    auto begin()
    {
        return data_.begin();
    }
    auto end()
    {
        return data_.end();
    }
    auto begin() const
    {
        return data_.begin();
    }
    auto end() const
    {
        return data_.end();
    }

    bool operator==(const ConstrainedVector& other) const
    {
        return data_ == other.data_;
    }

    // ========================================
    // Custom deserializer with constraint validation
    // ========================================
    struct Deser
    {
        static ValidationResult parse(ConstrainedVector& obj, Node* node)
        {
            ValidationResult result;

            if (!node->isSequence())
            {
                result.addError("", "Expected sequence");
                return result;
            }

            obj.data_.clear();
            bool hasErrors = false;

            for (size_t i = 0; i < node->size(); ++i)
            {
                T elem{};
                auto elemNode = node->at(i);
                if (!elemNode)
                {
                    result.addError("[" + std::to_string(i) + "]", "Failed to get element");
                    hasErrors = true;
                    continue;
                }

                auto elemResult = from<T>(elem, elemNode.get());

                if (!elemResult.valid)
                {
                    for (auto& [f, e] : elemResult.errors)
                    {
                        result.addError("[" + std::to_string(i) + "]" + (f.empty() ? "" : "." + f),
                                        e);
                    }
                    hasErrors = true;
                    continue;
                }

                // Validate element constraint
                if (!obj.elementConstraint_.validate(elem))
                {
                    result.addError("[" + std::to_string(i) + "]",
                                    "Element constraint violated: " +
                                        obj.elementConstraint_.error(elem));
                    hasErrors = true;
                    continue;
                }

                obj.data_.push_back(elem);
            }

            result.valid = !hasErrors;
            return result;
        }
    };

    // ========================================
    // Custom serializer
    // ========================================
    struct Ser
    {
        static void write(const ConstrainedVector& obj, Builder* b)
        {
            b->startSeq("");
            for (const auto& elem : obj.data_)
            {
                to(elem, b);
            }
            b->endSeq();
        }
    };

  private:
    std::vector<T> data_;
    ElementConstraint elementConstraint_;
};

// ============================================================================
// CONSTRAINTS
// ============================================================================

struct AnyConstraint
{
    bool validate(const auto&) const
    {
        return true;
    }
    std::string error(const auto&) const
    {
        return "";
    }
};

struct PositiveIntConstraint
{
    bool validate(int val) const
    {
        return val > 0;
    }
    std::string error(int val) const
    {
        return "Value " + std::to_string(val) + " must be positive";
    }
};

struct NonNegativeIntConstraint
{
    bool validate(int val) const
    {
        return val >= 0;
    }
    std::string error(int val) const
    {
        return "Value " + std::to_string(val) + " must be non-negative";
    }
};

struct NonEmptyStringConstraint
{
    bool validate(const std::string& s) const
    {
        return !s.empty();
    }
    std::string error(const std::string& s) const
    {
        return "String cannot be empty";
    }
};

// ============================================================================
// WHITELIST CONSTRAINTS
// ============================================================================

class StringKeyWhitelist
{
  private:
    std::vector<std::string> allowedKeys_;

  public:
    StringKeyWhitelist(const std::vector<std::string>& keys = {}) : allowedKeys_(keys)
    {
    }

    bool validate(const std::string& key) const
    {
        if (allowedKeys_.empty())
            return true;
        for (const auto& allowed : allowedKeys_)
        {
            if (key == allowed)
                return true;
        }
        return false;
    }

    std::string error(const std::string& key) const
    {
        std::string msg = "Key '" + key + "' not in whitelist: {";
        for (size_t i = 0; i < allowedKeys_.size(); ++i)
        {
            if (i > 0)
                msg += ", ";
            msg += "'" + allowedKeys_[i] + "'";
        }
        msg += "}";
        return msg;
    }
};

class IntValueWhitelist
{
  private:
    std::vector<int> allowedValues_;

  public:
    IntValueWhitelist(const std::vector<int>& values = {}) : allowedValues_(values)
    {
    }

    bool validate(int value) const
    {
        if (allowedValues_.empty())
            return true;
        for (auto allowed : allowedValues_)
        {
            if (value == allowed)
                return true;
        }
        return false;
    }

    std::string error(int value) const
    {
        std::string msg = "Value " + std::to_string(value) + " not in whitelist: {";
        for (size_t i = 0; i < allowedValues_.size(); ++i)
        {
            if (i > 0)
                msg += ", ";
            msg += std::to_string(allowedValues_[i]);
        }
        msg += "}";
        return msg;
    }
};

class StringValueWhitelist
{
  private:
    std::vector<std::string> allowedValues_;

  public:
    StringValueWhitelist(const std::vector<std::string>& values = {}) : allowedValues_(values)
    {
    }

    bool validate(const std::string& value) const
    {
        if (allowedValues_.empty())
            return true;
        for (const auto& allowed : allowedValues_)
        {
            if (value == allowed)
                return true;
        }
        return false;
    }

    std::string error(const std::string& value) const
    {
        std::string msg = "Value '" + value + "' not in whitelist: {";
        for (size_t i = 0; i < allowedValues_.size(); ++i)
        {
            if (i > 0)
                msg += ", ";
            msg += "'" + allowedValues_[i] + "'";
        }
        msg += "}";
        return msg;
    }
};

} // namespace meta

// ============================================================================
// EXAMPLE STRUCTURES
// ============================================================================

struct PortConfig
{
    std::string name;
    meta::ConstrainedVector<int, meta::PositiveIntConstraint> validPorts;

    PortConfig() : validPorts(meta::PositiveIntConstraint{})
    {
    }

    static constexpr auto fields = std::make_tuple(
        meta::Field<&PortConfig::name>("name", "Config name"),
        meta::Field<&PortConfig::validPorts>("validPorts",
                                             "List of valid ports (must be positive)"));

    bool operator==(const PortConfig& other) const
    {
        return name == other.name && validPorts == other.validPorts;
    }
};

struct UserPreferences
{
    std::string username;
    meta::ConstrainedMap<std::string,
                         std::string,
                         meta::StringKeyWhitelist,
                         meta::NonEmptyStringConstraint>
        preferences;

    UserPreferences()
        : preferences(meta::StringKeyWhitelist({"theme", "language", "timezone", "notifications"}),
                      meta::NonEmptyStringConstraint{})
    {
    }

    static constexpr auto fields = std::make_tuple(
        meta::Field<&UserPreferences::username>("username", "Username"),
        meta::Field<&UserPreferences::preferences>("preferences", "User preferences"));

    bool operator==(const UserPreferences& other) const
    {
        return username == other.username && preferences == other.preferences;
    }
};

struct StatusCodes
{
    std::string service;
    meta::ConstrainedMap<std::string, int, meta::StringKeyWhitelist, meta::PositiveIntConstraint>
        codes;

    StatusCodes()
        : codes(meta::StringKeyWhitelist({"success", "error", "warning", "info"}),
                meta::PositiveIntConstraint{})
    {
    }

    static constexpr auto fields =
        std::make_tuple(meta::Field<&StatusCodes::service>("service", "Service name"),
                        meta::Field<&StatusCodes::codes>("codes", "HTTP status codes"));

    bool operator==(const StatusCodes& other) const
    {
        return service == other.service && codes == other.codes;
    }
};

// ============================================================================
// MAIN - Examples
// ============================================================================

int main()
{
    std::cout << "=== ConstrainedMap and ConstrainedVector ===\n\n";

    // ========================================
    // Example 1: Valid PortConfig
    // ========================================
    std::cout << "--- Example 1: Valid PortConfig ---\n";

    std::string ports_yaml = R"(
name: WebServer
validPorts:
  - 80
  - 443
  - 8080
  - 8443
)";

    auto [ports, result1] = meta::reifyFromYaml<PortConfig>(ports_yaml);
    if (result1.valid && ports)
    {
        std::cout << "✓ Parsed successfully\n";
        std::cout << "  Ports: " << ports->validPorts.size() << " entries\n";
        std::cout << "\nYAML:\n" << meta::toYaml(*ports);
    }
    else
    {
        std::cout << "✗ Failed:\n";
        for (const auto& [field, err] : result1.errors)
        {
            std::cout << "  " << field << ": " << err << "\n";
        }
    }

    // ========================================
    // Example 2: Invalid - negative port number
    // ========================================
    std::cout << "\n--- Example 2: Invalid Port (Negative) ---\n";

    std::string bad_ports = R"(
name: BadServer
validPorts:
  - 80
  - -1
  - 443
)";

    auto [ports2, result2] = meta::reifyFromYaml<PortConfig>(bad_ports);
    if (!result2.valid)
    {
        std::cout << "✓ Validation correctly caught error:\n";
        for (const auto& [field, err] : result2.errors)
        {
            std::cout << "  " << field << ": " << err << "\n";
        }
    }

    // ========================================
    // Example 3: Valid UserPreferences
    // ========================================
    std::cout << "\n--- Example 3: Valid UserPreferences ---\n";

    std::string prefs_yaml = R"(
username: alice
preferences:
  theme: dark
  language: en
  timezone: UTC
  notifications: enabled
)";

    auto [prefs, result3] = meta::reifyFromYaml<UserPreferences>(prefs_yaml);
    if (result3.valid && prefs)
    {
        std::cout << "✓ Parsed successfully\n";
        std::cout << "  User: " << prefs->username << "\n";
        std::cout << "  Preferences: " << prefs->preferences.size() << " entries\n";
        std::cout << "\nYAML:\n" << meta::toYaml(*prefs);
    }
    else
    {
        std::cout << "✗ Failed:\n";
        for (const auto& [field, err] : result3.errors)
        {
            std::cout << "  " << field << ": " << err << "\n";
        }
    }

    // ========================================
    // Example 4: Invalid - disallowed preference key
    // ========================================
    std::cout << "\n--- Example 4: Invalid Preference Key ---\n";

    std::string bad_prefs = R"(
username: bob
preferences:
  theme: light
  invalidKey: value
  language: fr
)";

    auto [prefs2, result4] = meta::reifyFromYaml<UserPreferences>(bad_prefs);
    if (!result4.valid)
    {
        std::cout << "✓ Validation correctly caught error:\n";
        for (const auto& [field, err] : result4.errors)
        {
            std::cout << "  " << field << ": " << err << "\n";
        }
    }

    // ========================================
    // Example 5: Invalid - empty preference value
    // ========================================
    std::cout << "\n--- Example 5: Invalid Empty Preference Value ---\n";

    std::string empty_value = R"(
username: charlie
preferences:
  theme: dark
  language: ""
  timezone: UTC
)";

    auto [prefs3, result5] = meta::reifyFromYaml<UserPreferences>(empty_value);
    if (!result5.valid)
    {
        std::cout << "✓ Validation correctly caught error:\n";
        for (const auto& [field, err] : result5.errors)
        {
            std::cout << "  " << field << ": " << err << "\n";
        }
    }

    // ========================================
    // Example 6: Valid StatusCodes
    // ========================================
    std::cout << "\n--- Example 6: Valid StatusCodes ---\n";

    std::string codes_yaml = R"(
service: AuthService
codes:
  success: 200
  error: 500
  warning: 401
  info: 204
)";

    auto [codes, result6] = meta::reifyFromYaml<StatusCodes>(codes_yaml);
    if (result6.valid && codes)
    {
        std::cout << "✓ Parsed successfully\n";
        std::cout << "\nYAML:\n" << meta::toYaml(*codes);
    }
    else
    {
        std::cout << "✗ Failed:\n";
        for (const auto& [field, err] : result6.errors)
        {
            std::cout << "  " << field << ": " << err << "\n";
        }
    }

    // ========================================
    // Example 7: Invalid - zero status code
    // ========================================
    std::cout << "\n--- Example 7: Invalid Status Code (Zero) ---\n";

    std::string bad_codes = R"(
service: BadService
codes:
  success: 200
  error: 0
  warning: 401
)";

    auto [codes2, result7] = meta::reifyFromYaml<StatusCodes>(bad_codes);
    if (!result7.valid)
    {
        std::cout << "✓ Validation correctly caught error:\n";
        for (const auto& [field, err] : result7.errors)
        {
            std::cout << "  " << field << ": " << err << "\n";
        }
    }

    // ========================================
    // Example 8: Programmatic insertion with constraints
    // ========================================
    std::cout << "\n--- Example 8: Programmatic Insertion (Valid) ---\n";

    PortConfig cfg;
    cfg.name = "LoadBalancer";
    try
    {
        cfg.validPorts.push_back(80);
        cfg.validPorts.push_back(443);
        cfg.validPorts.push_back(3000);
        std::cout << "✓ Valid ports inserted\n";
        std::cout << "  Total ports: " << cfg.validPorts.size() << "\n";
    }
    catch (const std::runtime_error& e)
    {
        std::cout << "✗ Error: " << e.what() << "\n";
    }

    // ========================================
    // Example 9: Programmatic insertion - constraint violation
    // ========================================
    std::cout << "\n--- Example 9: Programmatic Insertion (Invalid) ---\n";

    PortConfig cfg2;
    cfg2.name = "BadServer";
    try
    {
        cfg2.validPorts.push_back(80);
        cfg2.validPorts.push_back(-8080); // This should throw
        std::cout << "✗ Should have thrown!\n";
    }
    catch (const std::runtime_error& e)
    {
        std::cout << "✓ Constraint correctly caught error:\n";
        std::cout << "  " << e.what() << "\n";
    }

    // ========================================
    // Example 10: Serialization roundtrip
    // ========================================
    std::cout << "\n--- Example 10: Serialization Roundtrip ---\n";

    UserPreferences original;
    original.username = "roundtrip_user";
    original.preferences.insert("theme", "dark");
    original.preferences.insert("language", "en");
    original.preferences.insert("timezone", "America/New_York");
    original.preferences.insert("notifications", "enabled");

    std::string serialized = meta::toYaml(original);
    std::cout << "Serialized:\n" << serialized;

    auto [restored, result10] = meta::reifyFromYaml<UserPreferences>(serialized);
    if (result10.valid && restored && original == *restored)
    {
        std::cout << "\n✓ Roundtrip successful - constraints validated on deserialize\n";
    }
    else
    {
        std::cout << "\n✗ Roundtrip failed\n";
    }

    std::cout << "\n=== All Examples Complete ===\n";
    return 0;
}

/*
 * meta.h - C++20 Serialization Framework
 *
 * This test file was automatically generated by Claude UI to demonstrate
 * the capabilities and features of the meta.h C++20 serialization framework.
 */

#include <iostream>
#include <string>

#include "meta.h"

namespace meta
{

// ============================================================================
// BOUNDED INT - Custom type with validation
// ============================================================================

template <int Min, int Max> struct BoundedInt
{
    int val;

    BoundedInt(int v = Min) : val(v)
    {
    }

    static constexpr int minVal = Min;
    static constexpr int maxVal = Max;

    bool isValid() const
    {
        return val >= Min && val <= Max;
    }
    bool operator==(const BoundedInt& other) const
    {
        return val == other.val;
    }

    // Custom deserializer with validation
    struct Deser
    {
        static ValidationResult parse(BoundedInt& obj, Node* node)
        {
            auto v = node->asInt();
            if (!v)
            {
                ValidationResult r;
                r.addError("", "Invalid integer");
                return r;
            }
            int value = *v;
            if (value < Min || value > Max)
            {
                ValidationResult r;
                r.addError("",
                           "Value " + std::to_string(value) + " out of bounds [" +
                               std::to_string(Min) + ", " + std::to_string(Max) + "]");
                return r;
            }
            obj.val = value;
            return ValidationResult();
        }
    };

    // Custom serializer
    struct Ser
    {
        static void write(const BoundedInt& obj, Builder* b)
        {
            b->writeInt(obj.val);
        }
    };
};

// ============================================================================
// BOUNDED STRING - Custom type with length validation
// ============================================================================

template <size_t MinLen, size_t MaxLen> struct BoundedString
{
    std::string val;

    BoundedString() : val(std::string(MinLen, ' '))
    {
    }
    BoundedString(const std::string& v) : val(v)
    {
    }

    static constexpr size_t minLen = MinLen;
    static constexpr size_t maxLen = MaxLen;

    bool isValid() const
    {
        return val.length() >= MinLen && val.length() <= MaxLen;
    }
    bool operator==(const BoundedString& other) const
    {
        return val == other.val;
    }

    // Custom deserializer with validation
    struct Deser
    {
        static ValidationResult parse(BoundedString& obj, Node* node)
        {
            auto s = node->asString();
            if (!s)
            {
                ValidationResult r;
                r.addError("", "Invalid string");
                return r;
            }
            if (s->length() < MinLen || s->length() > MaxLen)
            {
                ValidationResult r;
                r.addError("",
                           "String length " + std::to_string(s->length()) + " out of bounds [" +
                               std::to_string(MinLen) + ", " + std::to_string(MaxLen) + "]");
                return r;
            }
            obj.val = *s;
            return ValidationResult();
        }
    };

    // Custom serializer
    struct Ser
    {
        static void write(const BoundedString& obj, Builder* b)
        {
            b->writeString(obj.val);
        }
    };
};

} // namespace meta

// ============================================================================
// TYPE ALIASES - User-friendly names for bounded types
// ============================================================================

using Name = meta::BoundedString<1, 100>;     // 1-100 chars
using Age = meta::BoundedInt<0, 150>;         // 0-150
using Score = meta::BoundedInt<0, 100>;       // 0-100
using Hostname = meta::BoundedString<1, 255>; // 1-255 chars
using Port = meta::BoundedInt<1, 65535>;      // 1-65535

// ============================================================================
// PERSON STRUCT
// ============================================================================

struct Person
{
    Name name;
    Age age;
    Score score;

    static constexpr auto fields =
        std::make_tuple(meta::Field<&Person::name>("name", "Person's name"),
                        meta::Field<&Person::age>("age", "Person's age (0-150)"),
                        meta::Field<&Person::score>("score", "Person's score (0-100)"));
};

// ============================================================================
// APPCONFIG STRUCT
// ============================================================================

struct AppConfig
{
    Hostname hostname;
    Port port;
    std::map<std::string, std::string> settings;

    static constexpr auto fields =
        std::make_tuple(meta::Field<&AppConfig::hostname>("hostname", "Server hostname"),
                        meta::Field<&AppConfig::port>("port", "Server port"),
                        meta::Field<&AppConfig::settings>("settings", "Settings map"));
};

// ============================================================================
// MAIN
// ============================================================================

int main()
{
    std::cout << "=== Bounded Types with Validation ===\n\n";

    // ========================================
    // Example 1: Valid Person
    // ========================================
    std::cout << "--- Example 1: Valid Person ---\n";

    std::string person_yaml = R"(
name: Alice Johnson
age: 28
score: 95
)";

    auto [person, result1] = meta::reifyFromYaml<Person>(person_yaml);
    if (result1.valid && person)
    {
        std::cout << "✓ Parsed successfully\n";
        std::cout << "\nYAML:\n" << meta::toYaml(*person);
        std::cout << "\nJSON:\n" << meta::toJson(*person) << "\n";
    }
    else
    {
        std::cout << "✗ Failed:\n";
        for (const auto& [field, err] : result1.errors)
        {
            std::cout << "  " << field << ": " << err << "\n";
        }
    }

    // ========================================
    // Example 2: Invalid - age out of bounds
    // ========================================
    std::cout << "\n--- Example 2: Age Out of Bounds ---\n";

    std::string invalid_person = R"(
name: Bob
age: 200
score: 95
)";

    auto [person2, result2] = meta::reifyFromYaml<Person>(invalid_person);
    if (!result2.valid)
    {
        std::cout << "✓ Validation correctly caught error:\n";
        for (const auto& [field, err] : result2.errors)
        {
            std::cout << "  " << field << ": " << err << "\n";
        }
    }

    // ========================================
    // Example 3: Invalid - string too long
    // ========================================
    std::cout << "\n--- Example 3: Name Too Long ---\n";

    std::string long_name = R"(
name: This is a very very very very very very very very very very very very long name that exceeds 100 characters
age: 30
score: 85
)";

    auto [person3, result3] = meta::reifyFromYaml<Person>(long_name);
    if (!result3.valid)
    {
        std::cout << "✓ Validation correctly caught error:\n";
        for (const auto& [field, err] : result3.errors)
        {
            std::cout << "  " << field << ": " << err << "\n";
        }
    }

    // ========================================
    // Example 4: Valid AppConfig
    // ========================================
    std::cout << "\n--- Example 4: Valid AppConfig ---\n";

    std::string config_yaml = R"(
hostname: api.example.com
port: 8080
settings:
  timeout: "30"
  retries: "3"
  debug: "false"
)";

    auto [config, result4] = meta::reifyFromYaml<AppConfig>(config_yaml);
    if (result4.valid && config)
    {
        std::cout << "✓ Config parsed successfully\n";
        std::cout << "\nYAML:\n" << meta::toYaml(*config);
        std::cout << "\nJSON:\n" << meta::toJson(*config) << "\n";
    }
    else
    {
        std::cout << "✗ Failed:\n";
        for (const auto& [field, err] : result4.errors)
        {
            std::cout << "  " << field << ": " << err << "\n";
        }
    }

    // ========================================
    // Example 5: Invalid - port out of range
    // ========================================
    std::cout << "\n--- Example 5: Port Out of Range ---\n";

    std::string bad_config = R"(
hostname: localhost
port: 99999
settings:
  key: value
)";

    auto [config5, result5] = meta::reifyFromYaml<AppConfig>(bad_config);
    if (!result5.valid)
    {
        std::cout << "✓ Validation correctly caught error:\n";
        for (const auto& [field, err] : result5.errors)
        {
            std::cout << "  " << field << ": " << err << "\n";
        }
    }

    // ========================================
    // Example 6: Missing required field
    // ========================================
    std::cout << "\n--- Example 6: Missing Required Field ---\n";

    std::string incomplete = R"(
name: Charlie
age: 35
)";

    auto [person6, result6] = meta::reifyFromYaml<Person>(incomplete);
    if (!result6.valid)
    {
        std::cout << "✓ Validation correctly caught error:\n";
        for (const auto& [field, err] : result6.errors)
        {
            std::cout << "  " << field << ": " << err << "\n";
        }
    }

    std::cout << "\n=== All Examples Complete ===\n";
    return 0;
}

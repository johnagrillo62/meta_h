/*
 * test_enum_support.cpp - Test enum support in meta_yaml.h
 * 
 * Generated by Claude UI to test enum serialization/deserialization
 */

#include "meta_yaml.h"
#include <iostream>
#include <cassert>

// ============================================================================
// TEST ENUMS
// ============================================================================

enum class LogLevel { Debug, Info, Warning, Error };
enum class Status { Active, Inactive, Pending };

// Enum mappings
constexpr std::array LogLevelMapping = std::array{
    std::pair{LogLevel::Debug, "debug"},
    std::pair{LogLevel::Info, "info"},
    std::pair{LogLevel::Warning, "warning"},
    std::pair{LogLevel::Error, "error"},
};

constexpr std::array StatusMapping = std::array{
    std::pair{Status::Active, "active"},
    std::pair{Status::Inactive, "inactive"},
    std::pair{Status::Pending, "pending"},
};

// Register enums in global namespace
template <> struct meta::EnumMapping<LogLevel> {
    static constexpr auto& mapping = LogLevelMapping;
    using Type = meta::EnumTraitsAuto<LogLevel, LogLevelMapping>;
};

template <> struct meta::EnumMapping<Status> {
    static constexpr auto& mapping = StatusMapping;
    using Type = meta::EnumTraitsAuto<Status, StatusMapping>;
};

// ============================================================================
// TEST STRUCTS
// ============================================================================

struct LogEntry {
    std::string message;
    LogLevel level;

    static constexpr auto fields = std::tuple{
        meta::Field<&LogEntry::message>{"message"},
        meta::Field<&LogEntry::level>{"level"}
    };
};

struct Service {
    std::string name;
    Status status;
    std::vector<LogEntry> logs;

    static constexpr auto fields = std::tuple{
        meta::Field<&Service::name>{"name"},
        meta::Field<&Service::status>{"status"},
        meta::Field<&Service::logs>{"logs"}
    };
};

// ============================================================================
// TESTS
// ============================================================================

void test_enum_serialization() {
    std::cout << "=== Test 1: Enum Serialization ===" << std::endl;
    
    LogLevel level = LogLevel::Warning;
    auto node = meta::to(level);
    std::cout << "Serialized LogLevel::Warning: " << node << std::endl;
    
    LogLevel level2 = LogLevel::Error;
    auto node2 = meta::to(level2);
    std::cout << "Serialized LogLevel::Error: " << node2 << std::endl;
    
    assert(node.as<std::string>() == "warning");
    assert(node2.as<std::string>() == "error");
    
    std::cout << "✓ Enum serialization test passed\n" << std::endl;
}

void test_enum_deserialization() {
    std::cout << "=== Test 2: Enum Deserialization ===" << std::endl;
    
    YAML::Node warningNode = YAML::Node("warning");
    LogLevel level;
    auto result = meta::from(level, meta::Node(warningNode));
    assert(result.valid);
    assert(level == LogLevel::Warning);
    std::cout << "✓ Deserialized 'warning' to LogLevel::Warning" << std::endl;
    
    YAML::Node debugNode = YAML::Node("debug");
    LogLevel level2;
    auto result2 = meta::from(level2, meta::Node(debugNode));
    assert(result2.valid);
    assert(level2 == LogLevel::Debug);
    std::cout << "✓ Deserialized 'debug' to LogLevel::Debug\n" << std::endl;
}

void test_invalid_enum() {
    std::cout << "=== Test 3: Invalid Enum ===" << std::endl;
    
    YAML::Node invalidNode = YAML::Node("invalid_level");
    LogLevel level;
    auto result = meta::from(level, meta::Node(invalidNode));
    
    if (!result.valid) {
        std::cout << "✓ Correctly rejected invalid enum value" << std::endl;
        for (const auto &[field, error] : result.errors) {
            std::cout << "  Error: " << error << std::endl;
        }
        std::cout << std::endl;
    } else {
        std::cout << "✗ Should have rejected invalid enum\n" << std::endl;
    }
}

void test_struct_with_enum() {
    std::cout << "=== Test 4: Struct with Enum ===" << std::endl;
    
    LogEntry entry{"Application started", LogLevel::Info};
    auto node = meta::to(entry);
    
    std::cout << "Serialized LogEntry:\n" << node << std::endl;
    
    // Verify structure
    assert(node["message"].as<std::string>() == "Application started");
    assert(node["level"].as<std::string>() == "info");
    
    // Deserialize
    LogEntry deserialized;
    auto result = meta::from(deserialized, meta::Node(node));
    assert(result.valid);
    assert(deserialized.message == "Application started");
    assert(deserialized.level == LogLevel::Info);
    
    std::cout << "✓ Struct with enum test passed\n" << std::endl;
}

void test_vector_of_enum_structs() {
    std::cout << "=== Test 5: Vector of Enum Structs ===" << std::endl;
    
    Service api{
        "API Service",
        Status::Active,
        {
            {"Started successfully", LogLevel::Info},
            {"High memory usage", LogLevel::Warning},
            {"Request timeout", LogLevel::Error}
        }
    };
    
    auto node = meta::to(api);
    std::cout << "Serialized Service:\n" << node << std::endl;
    
    // Verify
    assert(node["name"].as<std::string>() == "API Service");
    assert(node["status"].as<std::string>() == "active");
    assert(node["logs"].size() == 3);
    assert(node["logs"][0]["level"].as<std::string>() == "info");
    assert(node["logs"][1]["level"].as<std::string>() == "warning");
    assert(node["logs"][2]["level"].as<std::string>() == "error");
    
    // Deserialize
    Service deserialized;
    auto result = meta::from(deserialized, meta::Node(node));
    assert(result.valid);
    assert(deserialized.name == "API Service");
    assert(deserialized.status == Status::Active);
    assert(deserialized.logs.size() == 3);
    assert(deserialized.logs[0].level == LogLevel::Info);
    assert(deserialized.logs[2].level == LogLevel::Error);
    
    std::cout << "✓ Vector of enum structs test passed\n" << std::endl;
}

void test_enum_yaml_roundtrip() {
    std::cout << "=== Test 6: Enum YAML Roundtrip ===" << std::endl;
    
    LogEntry entry{"Error occurred", LogLevel::Error};
    std::string yaml = meta::toYaml(entry);
    
    std::cout << "Generated YAML:\n" << yaml << std::endl;
    
    auto [deserialized, result] = meta::fromYaml<LogEntry>(yaml);
    assert(result.valid);
    assert(deserialized->message == "Error occurred");
    assert(deserialized->level == LogLevel::Error);
    
    std::cout << "✓ Enum YAML roundtrip test passed\n" << std::endl;
}

void test_enum_operator() {
    std::cout << "=== Test 7: Enum Operator<< ===" << std::endl;
    
    LogLevel level = LogLevel::Warning;
    std::cout << "LogLevel using operator<<: " << level << std::endl;
    
    Status status = Status::Active;
    std::cout << "Status using operator<<: " << status << std::endl;
    
    std::cout << "✓ Enum operator<< test passed\n" << std::endl;
}

void test_to_enum_function() {
    std::cout << "=== Test 8: toEnum Function ===" << std::endl;
    
    auto level = meta::toEnum<LogLevel>("warning");
    assert(level.has_value());
    assert(level.value() == LogLevel::Warning);
    std::cout << "✓ toEnum('warning') returned LogLevel::Warning" << std::endl;
    
    auto status = meta::toEnum<Status>("active");
    assert(status.has_value());
    assert(status.value() == Status::Active);
    std::cout << "✓ toEnum('active') returned Status::Active" << std::endl;
    
    auto invalid = meta::toEnum<LogLevel>("invalid");
    assert(!invalid.has_value());
    std::cout << "✓ toEnum('invalid') correctly returned empty optional\n" << std::endl;
}

void test_enum_values_function() {
    std::cout << "=== Test 9: enumValues Function ===" << std::endl;
    
    auto levels = meta::enumValues<LogLevel>();
    std::cout << "LogLevel values: ";
    for (auto level : levels) {
        std::cout << level << " ";
    }
    std::cout << std::endl;
    
    assert(levels.size() == 4);
    std::cout << "✓ enumValues<LogLevel>() returned all 4 values" << std::endl;
    
    auto statuses = meta::enumValues<Status>();
    std::cout << "Status values: ";
    for (auto status : statuses) {
        std::cout << status << " ";
    }
    std::cout << std::endl;
    
    assert(statuses.size() == 3);
    std::cout << "✓ enumValues<Status>() returned all 3 values\n" << std::endl;
}

int main() {
    std::cout << "\n╔════════════════════════════════════════════════════════════╗" << std::endl;
    std::cout << "║  meta_yaml.h - Enum Support Tests                           ║" << std::endl;
    std::cout << "╚════════════════════════════════════════════════════════════╝\n" << std::endl;

    try {
        test_enum_serialization();
        test_enum_deserialization();
        test_invalid_enum();
        test_struct_with_enum();
        test_vector_of_enum_structs();
        test_enum_yaml_roundtrip();
        test_enum_operator();
        test_to_enum_function();
        test_enum_values_function();

        std::cout << "╔════════════════════════════════════════════════════════════╗" << std::endl;
        std::cout << "║  ✓ ALL ENUM TESTS PASSED                                   ║" << std::endl;
        std::cout << "╚════════════════════════════════════════════════════════════╝\n" << std::endl;
        
        return 0;
    } catch (const std::exception &e) {
        std::cerr << "✗ Test failed with exception: " << e.what() << std::endl;
        return 1;
    }
}

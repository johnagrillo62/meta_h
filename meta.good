// meta.h - Type-safe serialization using templates
// John A Grillo with assistance from Claude AI
//
// Just a fun way to experiment with reflection in C++.
// Collaborative effort with AI after many iterations to make an
// easy and fun to use reflection simulator. I had a basic understanding
// of templates, not enough to pull this off - AI helped get the ordering
// right and taught me how templates actually work.
//
// Supports YAML, JSON. No macros, compile-time type checking.
// Uses overload resolution, explicit specializations for primitives,
// and if constexpr for generic dispatch.

#pragma once

#include <array>
#include <deque>
#include <filesystem>
#include <iostream>
#include <map>
#include <memory>
#include <optional>
#include <set>
#include <sstream>
#include <string>
#include <tuple>
#include <type_traits>
#include <unordered_map>
#include <vector>
#include <cstdint>
#include <yaml-cpp/yaml.h>

#include "field.h"


namespace meta
{

//============================================================
// TYPE CONCEPTS
//============================================================

template <typename T>
concept IntegerType = std::is_integral_v<T> && !std::is_same_v<T, bool>;

template <typename T>
concept FloatingPointType = std::is_floating_point_v<T>;

// ============================================================================
// META TUPLE
// ============================================================================
template <typename T> 
struct MetaTuple
{
    static_assert(sizeof(T) == 0, "No metadata tuple defined for this type");
};


//============================================================
// FIELD LOCATION HELPER
//============================================================

// Helper to get fields from either T::fields or meta::MetaTuple<T>::fields
template <typename T>
concept HasDirectFields = requires { T::fields; };

template <typename T>
concept HasMetaTupleFields = requires { meta::MetaTuple<T>::fields; };

template <typename T>
concept HasFields = HasDirectFields<T> || HasMetaTupleFields<T>;

template <typename T>
constexpr decltype(auto) get_fields()
{
    if constexpr (HasDirectFields<T>)
        return (T::fields);
    else if constexpr (HasMetaTupleFields<T>)
        return (meta::MetaTuple<T>::fields);
    else
        static_assert(HasDirectFields<T> || HasMetaTupleFields<T>, 
                     "Type must have either T::fields or meta::MetaTuple<T>::fields");
}
  
  
//============================================================
// ENUM SUPPORT
//============================================================

// Enum support - register your enums by specializing EnumMapping
template <typename T> struct EnumMapping;

template <typename EnumT, auto& MappingArray> struct EnumTraitsAuto
{
    inline static constexpr auto& mapping = MappingArray;

    inline static const std::unordered_map<EnumT, std::string> enumToString = []()
    {
        std::unordered_map<EnumT, std::string> m;
        for (auto [e, s] : mapping)
            m[e] = s;
        return m;
    }();

    inline static const std::unordered_map<std::string, EnumT> stringToEnum = []()
    {
        std::unordered_map<std::string, EnumT> m;
        for (auto [e, s] : mapping)
            m[s] = e;
        return m;
    }();

    static std::string toString(EnumT e)
    {
        auto it = enumToString.find(e);
        return it != enumToString.end() ? it->second : "";
    }

    static std::optional<EnumT> fromString(const std::string& s)
    {
        auto it = stringToEnum.find(s);
        return it != stringToEnum.end() ? std::optional(it->second) : std::nullopt;
    }

    template <typename Func> static void forEach(Func f)
    {
        for (auto [e, _] : mapping)
            f(e);
    }

    static std::string validValues()
    {
        std::string out;
        bool first = true;
        for (auto [_, s] : mapping)
        {
            if (!first) out += ", ";
            first = false;
            out += s;
        }
        return out;
    }
};

template <typename EnumT>
concept RegisteredEnum = requires { typename EnumMapping<EnumT>::Type; };

template <typename EnumT>
    requires RegisteredEnum<EnumT>
std::ostream& operator<<(std::ostream& os, EnumT e);

struct ValidationResult
{
    bool valid = true;
    std::vector<std::pair<std::string, std::string>> errors;
    
    void addError(std::string_view fieldName, std::string_view message)
    {
        valid = false;
        errors.push_back({std::string(fieldName), std::string(message)});
    }
};

  
// Abstract interfaces for format-agnostic serialization
struct Node
{
    virtual ~Node() = default;
    virtual std::optional<int> asInt() const = 0;
    virtual std::optional<double> asDouble() const = 0;
    virtual std::optional<bool> asBool() const = 0;
    virtual std::optional<std::string> asString() const = 0;
    virtual bool isSequence() const = 0;
    virtual bool isMap() const = 0;
    virtual bool isNull() const = 0;
    virtual size_t size() const = 0;
    virtual std::unique_ptr<Node> at(size_t i) const = 0;
    virtual std::unique_ptr<Node> at(std::string k) const = 0;
    virtual std::vector<std::string> keys() const = 0;
};

struct Builder
{
    virtual ~Builder() = default;
    virtual void writeInt(int v) = 0;
    virtual void writeDouble(double v) = 0;
    virtual void writeBool(bool v) = 0;
    virtual void writeString(const std::string& v) = 0;
    virtual void writeNull() = 0;
    virtual void startSeq(const std::string& elemType = "") = 0;
    virtual void endSeq() = 0;
    virtual void startFlowSeq() { startSeq(""); }
    virtual void endFlowSeq() { endSeq(); }
    virtual void startMap(const std::string& valueType = "") = 0;
    virtual void endMap() = 0;
    virtual void key(const std::string& k) = 0;
    virtual std::string result() = 0;
};

// YAML implementation
class YamlNode : public Node
{
    YAML::Node node;

  public:
    YamlNode(YAML::Node n) : node(n) {}

    std::optional<int> asInt() const override
    {
        try { return node.as<int>(); }
        catch (...) { return {}; }
    }

    std::optional<double> asDouble() const override
    {
        try { return node.as<double>(); }
        catch (...) { return {}; }
    }

    std::optional<bool> asBool() const
    {
        try { return node.as<bool>(); }
        catch (...) { return {}; }
    }

    std::optional<std::string> asString() const override
    {
        try { return node.as<std::string>(); }
        catch (...) { return {}; }
    }

    bool isSequence() const override { return node.IsSequence(); }
    bool isMap() const override { return node.IsMap(); }
    bool isNull() const override { return node.IsNull(); }
    size_t size() const override { return node.size(); }

    std::unique_ptr<Node> at(size_t i) const override
    {
        return std::make_unique<YamlNode>(node[i]);
    }

    std::unique_ptr<Node> at(std::string k) const override
    {
        if (!node[k])
            return nullptr;
        return std::make_unique<YamlNode>(node[k]);
    }

    std::vector<std::string> keys() const override
    {
        std::vector<std::string> k;
        for (auto& item : node)
            if (item.first.IsScalar())
                k.push_back(item.first.as<std::string>());
        return k;
    }
};

class YamlBuilder : public Builder
{
    YAML::Emitter out;

  public:
    void writeInt(int v) override
    {
        out << v;
    }

    void writeDouble(double v) override
    {
        out << v;
    }

    void writeBool(bool v) override
    {
        out << v;
    }

    void writeString(const std::string& v) override
    {
        out << v;
    }

    void writeNull() override
    {
        out << YAML::Null;
    }

    void startSeq(const std::string& elemType = "") override
    {
        out << YAML::BeginSeq;
    }

    void endSeq() override
    {
        out << YAML::EndSeq;
    }

    void startFlowSeq() override
    {
        out << YAML::Flow << YAML::BeginSeq;
    }

    void endFlowSeq() override
    {
        out << YAML::EndSeq;
    }

    void startMap(const std::string& valueType = "") override
    {
        out << YAML::BeginMap;
    }

    void endMap() override
    {
        out << YAML::EndMap;
    }

    void key(const std::string& k) override
    {
        out << YAML::Key << k << YAML::Value;
    }

    std::string result() override 
    { 
        return out.c_str(); 
    }
};

  
  
class JsonBuilder : public Builder
{
    std::ostringstream out;
    bool needsComma = false;

    void comma()
    {
        if (needsComma)
            out << ",";
        needsComma = true;
    }

  public:
    void writeInt(int v) override { comma(); out << v; }
    void writeDouble(double v) override { comma(); out << v; }
    void writeBool(bool v) override { comma(); out << (v ? "true" : "false"); }
    void writeString(const std::string& v) override { comma(); out << "\"" << v << "\""; }
    void writeNull() override { comma(); out << "null"; }

    void startSeq(const std::string& = "") override
    {
        if (needsComma) out << ",";
        out << "[";
        needsComma = false;
    }

    void endSeq() override { out << "]"; needsComma = true; }

    void startMap(const std::string& = "") override
    {
        if (needsComma) out << ",";
        out << "{";
        needsComma = false;
    }

    void endMap() override { out << "}"; needsComma = true; }

    void key(const std::string& k) override
    {
        comma();
        out << "\"" << k << "\":";
        needsComma = false;
    }

    std::string result() override
    {
        return out.str();
    }
};

class XmlBuilder : public Builder
{
    std::ostringstream out;
    int indentLevel = 0;

    void indent()
    {
        for (int i = 0; i < indentLevel; ++i)
            out << "  ";
    }

  public:
    XmlBuilder() { out << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<root>\n"; indentLevel++; }

    void writeInt(int v) override { out << v; }
    void writeDouble(double v) override { out << v; }
    void writeBool(bool v) override { out << (v ? "true" : "false"); }
    void writeString(const std::string& v) override { out << v; }
    void writeNull() override { /* XML nulls are empty elements */ }

    void startSeq(const std::string& = "") override
    {
        out << "\n";
        indent();
        out << "<sequence>\n";
        indentLevel++;
    }

    void endSeq() override
    {
        indentLevel--;
        indent();
        out << "</sequence>";
    }

    void startMap(const std::string& = "") override
    {
        out << "\n";
        indent();
        out << "<map>\n";
        indentLevel++;
    }

    void endMap() override
    {
        indentLevel--;
        indent();
        out << "</map>";
    }

    void key(const std::string& k) override
    {
        indent();
        out << "<" << k << ">";
    }

    void startFlowSeq() override { startSeq(); }
    void endFlowSeq() override { endSeq(); }

    std::string result() override
    {
        return out.str() + "\n</root>\n";
    }
};

//============================================================
// DESERIALIZATION (from)
//============================================================

// Forward declare main template
template <typename T> ValidationResult from(T& obj, Node* node);

// Primitive integer types - all convert through asInt()
template <IntegerType T>
ValidationResult from(T& obj, Node* node)
{
    auto val = node->asInt();
    if (!val)
    {
        ValidationResult r;
        r.addError("", "Expected integer");
        return r;
    }
    obj = static_cast<T>(*val);
    return ValidationResult();
}

// Floating point types
template <FloatingPointType T>
ValidationResult from(T& obj, Node* node)
{
    auto val = node->asDouble();
    if (!val)
    {
        ValidationResult r;
        r.addError("", "Expected number");
        return r;
    }
    obj = static_cast<T>(*val);
    return ValidationResult();
}

// Bool
template <> inline ValidationResult from(bool& obj, Node* node)
{
    auto val = node->asBool();
    if (!val)
    {
        ValidationResult r;
        r.addError("", "Expected boolean");
        return r;
    }
    obj = *val;
    return ValidationResult();
}

// String
template <> inline ValidationResult from(std::string& obj, Node* node)
{
    auto val = node->asString();
    if (!val)
    {
        ValidationResult r;
        r.addError("", "Expected string");
        return r;
    }
    obj = *val;
    return ValidationResult();
}

// Enum
template <RegisteredEnum EnumT>
ValidationResult from(EnumT& obj, Node* node)
{
    auto str = node->asString();
    if (!str)
    {
        ValidationResult r;
        r.addError("", "Expected string for enum");
        return r;
    }

    auto value = EnumMapping<EnumT>::Type::fromString(*str);
    if (!value)
    {
        ValidationResult r;
        std::string validVals = EnumMapping<EnumT>::Type::validValues();
        r.addError("", "Unknown enum value: '" + *str + "'. Valid values are: " + validVals);
        return r;
    }
    obj = *value;
    return ValidationResult();
}

// Vector
template <typename T>
ValidationResult from(std::vector<T>& obj, Node* node)
{
    if (!node->isSequence())
    {
        ValidationResult r;
        r.addError("", "Expected sequence");
        return r;
    }

    obj.clear();
    ValidationResult result;
    for (size_t i = 0; i < node->size(); ++i)
    {
        T elem{};
        auto elemResult = from(elem, node->at(i).get());
        if (!elemResult.valid)
        {
            for (auto& [f, e] : elemResult.errors)
                result.addError("[" + std::to_string(i) + "]" + (f.empty() ? "" : "." + f), e);
        }
        else
        {
            obj.push_back(std::move(elem));
        }
    }
    return result;
}

// Deque
template <typename T>
ValidationResult from(std::deque<T>& obj, Node* node)
{
    if (!node->isSequence())
    {
        ValidationResult r;
        r.addError("", "Expected sequence");
        return r;
    }

    obj.clear();
    ValidationResult result;
    for (size_t i = 0; i < node->size(); ++i)
    {
        T elem{};
        auto elemResult = from(elem, node->at(i).get());
        if (!elemResult.valid)
        {
            for (auto& [f, e] : elemResult.errors)
                result.addError("[" + std::to_string(i) + "]" + (f.empty() ? "" : "." + f), e);
        }
        else
        {
            obj.push_back(std::move(elem));
        }
    }
    return result;
}

// Set
template <typename T>
ValidationResult from(std::set<T>& obj, Node* node)
{
    if (!node->isSequence())
    {
        ValidationResult r;
        r.addError("", "Expected sequence");
        return r;
    }

    obj.clear();
    ValidationResult result;
    for (size_t i = 0; i < node->size(); ++i)
    {
        T elem{};
        auto elemResult = from(elem, node->at(i).get());
        if (!elemResult.valid)
        {
            for (auto& [f, e] : elemResult.errors)
                result.addError("[" + std::to_string(i) + "]" + (f.empty() ? "" : "." + f), e);
        }
        else
        {
            obj.insert(std::move(elem));
        }
    }
    return result;
}

// Map
template <typename K, typename V>
ValidationResult from(std::map<K, V>& obj, Node* node)
{
    if (!node->isMap())
    {
        ValidationResult r;
        r.addError("", "Expected map");
        return r;
    }

    obj.clear();
    ValidationResult result;
    for (const auto& k : node->keys())
    {
        K key;
        if constexpr (std::is_same_v<K, std::string>)
        {
            key = k;
        }
        else if constexpr (std::is_integral_v<K>)
        {
            try { key = static_cast<K>(std::stoi(k)); }
            catch (...)
            {
                result.addError(k, "Invalid key format");
                continue;
            }
        }

        V value{};
        auto valueResult = from(value, node->at(k).get());
        if (!valueResult.valid)
        {
            for (auto& [f, e] : valueResult.errors)
                result.addError(k + (f.empty() ? "" : "." + f), e);
        }
        else
        {
            obj[key] = std::move(value);
        }
    }
    return result;
}

// Unordered map
template <typename K, typename V>
ValidationResult from(std::unordered_map<K, V>& obj, Node* node)
{
    if (!node->isMap())
    {
        ValidationResult r;
        r.addError("", "Expected map");
        return r;
    }

    obj.clear();
    ValidationResult result;
    for (const auto& k : node->keys())
    {
        K key;
        if constexpr (std::is_same_v<K, std::string>)
        {
            key = k;
        }
        else if constexpr (std::is_integral_v<K>)
        {
            try { key = static_cast<K>(std::stoi(k)); }
            catch (...)
            {
                result.addError(k, "Invalid key format");
                continue;
            }
        }

        V value{};
        auto valueResult = from(value, node->at(k).get());
        if (!valueResult.valid)
        {
            for (auto& [f, e] : valueResult.errors)
                result.addError(k + (f.empty() ? "" : "." + f), e);
        }
        else
        {
            obj[key] = std::move(value);
        }
    }
    return result;
}

// Optional
template <typename T>
ValidationResult from(std::optional<T>& obj, Node* node)
{
    if (node->isNull())
    {
        obj = std::nullopt;
        return ValidationResult();
    }

    T value{};
    auto result = from(value, node);
    if (result.valid)
        obj = std::move(value);
    return result;
}

// Pair
template <typename K, typename V>
ValidationResult from(std::pair<K, V>& obj, Node* node)
{
    if (!node->isSequence() || node->size() != 2)
    {
        ValidationResult r;
        r.addError("", "Expected 2-element sequence for pair");
        return r;
    }

    ValidationResult result;
    auto firstResult = from(obj.first, node->at(0).get());
    if (!firstResult.valid)
    {
        for (auto& [f, e] : firstResult.errors)
            result.addError("[0]" + (f.empty() ? "" : "." + f), e);
    }

    auto secondResult = from(obj.second, node->at(1).get());
    if (!secondResult.valid)
    {
        for (auto& [f, e] : secondResult.errors)
            result.addError("[1]" + (f.empty() ? "" : "." + f), e);
    }

    return result;
}

// Tuple
template <typename... Args>
ValidationResult from(std::tuple<Args...>& obj, Node* node)
{
    constexpr size_t N = sizeof...(Args);
    if (!node->isSequence() || node->size() != N)
    {
        ValidationResult r;
        r.addError("", "Expected " + std::to_string(N) + "-element sequence for tuple");
        return r;
    }

    ValidationResult result;
    size_t idx = 0;
    std::apply(
        [&](auto&... args)
        {
            (..., [&](auto& arg)
             {
                 auto elemResult = from(arg, node->at(idx).get());
                 if (!elemResult.valid)
                 {
                     for (auto& [f, e] : elemResult.errors)
                         result.addError("[" + std::to_string(idx) + "]" + (f.empty() ? "" : "." + f), e);
                 }
                 idx++;
             }(args));
        },
        obj);
    return result;
}

// Structs with fields
template <typename T>
    requires requires { T::fields; }
ValidationResult from(T& obj, Node* node)
{
    if constexpr (requires { typename T::Deser; })
    {
        return T::Deser::read(obj, node);
    }
    else
    {
        if (!node->isMap())
        {
            ValidationResult r;
            r.addError("", "Expected map for struct");
            return r;
        }

        ValidationResult result;
        std::apply(
            [&](auto&&... fields)
            {
                (..., [&](auto& field)
                 {
                     auto fieldNode = node->at(std::string(field.fieldName));
                     if (!fieldNode)
                     {
                         if (field.requirement == Requirement::Required)
                             result.addError(field.fieldName, "Missing required field");
                         return;
                     }
                     auto fieldResult = from(obj.*(field.memberPtr), fieldNode.get());
                     if (!fieldResult.valid)
                         for (auto& [f, e] : fieldResult.errors)
                             result.addError(std::string(field.fieldName) + (f.empty() ? "" : "." + f), e);
                     
                     // Run validation attributes (BoundsCheck, StringLength, Whitelist, etc.)
                     std::apply([&](auto&&... attrs) {
                         (..., [&](auto& attr) {
                             using AttrType = std::decay_t<decltype(attr)>;
                             // Check if this attribute has a validate() method
                             if constexpr (requires { AttrType::validate(obj.*(field.memberPtr), std::declval<std::string&>()); }) {
                                 std::string error;
                                 if (!AttrType::validate(obj.*(field.memberPtr), error)) {
                                     result.addError(field.fieldName, error);
                                 }
                             }
                         }(attrs));
                     }, field.attributes);
                 }(fields));
            },
            T::fields);
        return result;
    }
}

//============================================================
// SERIALIZATION (to)
//============================================================

// Forward declare main template
template <typename T> void to(const T& obj, Builder* b);

// Primitive integer types - all write as int
template <IntegerType T>
void to(const T& obj, Builder* b)
{
    b->writeInt(static_cast<int>(obj));
}

// Floating point types
template <FloatingPointType T>
void to(const T& obj, Builder* b)
{
    b->writeDouble(static_cast<double>(obj));
}

// Bool
template <> inline void to(const bool& obj, Builder* b)
{
    b->writeBool(obj);
}

// String
template <> inline void to(const std::string& obj, Builder* b)
{
    b->writeString(obj);
}

// Enum
template <RegisteredEnum EnumT>
void to(const EnumT& obj, Builder* b)
{
    b->writeString(EnumMapping<EnumT>::Type::toString(obj));
}

// Vector
template <typename T>
void to(const std::vector<T>& obj, Builder* b)
{
    b->startSeq(typeid(T).name());
    for (const auto& e : obj)
        to(e, b);
    b->endSeq();
}

// Deque
template <typename T>
void to(const std::deque<T>& obj, Builder* b)
{
    b->startSeq(typeid(T).name());
    for (const auto& e : obj)
        to(e, b);
    b->endSeq();
}

// Set
template <typename T>
void to(const std::set<T>& obj, Builder* b)
{
    b->startSeq(typeid(T).name());
    for (const auto& e : obj)
        to(e, b);
    b->endSeq();
}

// Map
template <typename K, typename V>
void to(const std::map<K, V>& obj, Builder* b)
{
    b->startMap(typeid(V).name());
    for (const auto& [k, v] : obj)
    {
        if constexpr (std::is_same_v<K, std::string>)
        {
            b->key(k);
        }
        else if constexpr (std::is_integral_v<K>)
        {
            b->key(std::to_string(k));
        }
        to(v, b);
    }
    b->endMap();
}

// Unordered map
template <typename K, typename V>
void to(const std::unordered_map<K, V>& obj, Builder* b)
{
    b->startMap(typeid(V).name());
    for (const auto& [k, v] : obj)
    {
        if constexpr (std::is_same_v<K, std::string>)
        {
            b->key(k);
        }
        else if constexpr (std::is_integral_v<K>)
        {
            b->key(std::to_string(k));
        }
        to(v, b);
    }
    b->endMap();
}

// Optional
template <typename T>
void to(const std::optional<T>& obj, Builder* b)
{
    if (obj)
        to(*obj, b);
    else
        b->writeNull();
}

// Pair
template <typename K, typename V>
void to(const std::pair<K, V>& obj, Builder* b)
{
    b->startFlowSeq();
    to(obj.first, b);
    to(obj.second, b);
    b->endFlowSeq();
}

// Tuple
template <typename... Args>
void to(const std::tuple<Args...>& obj, Builder* b)
{
    b->startFlowSeq();
    std::apply([b](const auto&... args)
               { (..., [b](const auto& arg) { to(arg, b); }(args)); },
               obj);
    b->endFlowSeq();
}

// Structs with fields
template <typename T>
    requires requires { T::fields; }
void to(const T& obj, Builder* b)
{
    if constexpr (requires { typename T::Ser; })
    {
        T::Ser::write(obj, b);
    }
    else
    {
        b->startMap("");
        std::apply(
            [&](auto&&... fields)
            {
                (..., [&](auto& field)
                 {
                     b->key(std::string(field.fieldName));
                     to(obj.*(field.memberPtr), b);
                 }(fields));
            },
            T::fields);
        b->endMap();
    }
}

// Filesystem path support
template <> inline ValidationResult from(std::filesystem::path& obj, Node* node)
{
    auto str = node->asString();
    if (!str)
    {
        ValidationResult r;
        r.addError("path", "Must be string");
        return r;
    }
    obj = std::filesystem::path(*str);
    return ValidationResult();
}

template <> inline void to(const std::filesystem::path& obj, Builder* b)
{
    b->writeString(obj.string());
}

//============================================================
// PUBLIC API
//============================================================

template <typename T>
std::pair<std::optional<T>, ValidationResult> reifyFromYaml(const std::string& yaml)
{
    try
    {
        YAML::Node node = YAML::Load(yaml);
        YamlNode ynode(node);
        T obj{};
        auto result = from(obj, &ynode);
        return result.valid ? std::make_pair(std::optional(obj), result)
                            : std::make_pair(std::nullopt, result);
    }
    catch (const std::exception& e)
    {
        ValidationResult result;
        result.addError("yaml", std::string(e.what()));
        return {std::nullopt, result};
    }
}

template <typename T>
std::pair<std::optional<T>, ValidationResult> reifyFromYaml(const YAML::Node& node)
{
    try
    {
        YamlNode ynode(node);
        T obj{};
        auto result = from(obj, &ynode);
        return result.valid ? std::make_pair(std::optional(obj), result)
                            : std::make_pair(std::nullopt, result);
    }
    catch (const std::exception& e)
    {
        ValidationResult result;
        result.addError("yaml", std::string(e.what()));
        return {std::nullopt, result};
    }
}

template <typename T> std::string toYaml(const T& obj)
{
    YamlBuilder builder;
    to(obj, &builder);
    return builder.result();
}

template <typename T> std::string toJson(const T& obj)
{
    JsonBuilder builder;
    to(obj, &builder);
    return builder.result();
}

template <typename T> std::string toXml(const T& obj)
{
    XmlBuilder builder;
    to(obj, &builder);
    return builder.result();
}

template <typename T> std::string toString(const T& obj)
{
    return toYaml(obj);
}

template <typename T> bool checkForEquality(const T& a, const T& b)
{
    if constexpr (requires { T::fields; })
    {
        bool equal = true;
        std::apply(
            [&](auto&&... fields)
            {
                (..., [&](auto& field)
                 {
                     if (a.*(field.memberPtr) != b.*(field.memberPtr))
                         equal = false;
                 }(fields));
            },
            T::fields);
        return equal;
    }
    else
        return a == b;
}

template <typename EnumT>
    requires RegisteredEnum<EnumT>
std::ostream& operator<<(std::ostream& os, EnumT e)
{
    os << EnumMapping<EnumT>::Type::toString(e);
    return os;
}

template <typename EnumT>
    requires RegisteredEnum<EnumT>
std::optional<EnumT> toEnum(const std::string& s)
{
    return EnumMapping<EnumT>::Type::fromString(s);
}

template <typename EnumT>
    requires RegisteredEnum<EnumT>
std::vector<EnumT> enumValues()
{
    std::vector<EnumT> values;
    EnumMapping<EnumT>::Type::forEach([&](EnumT e) { values.push_back(e); });
    return values;
}


  
} // namespace meta


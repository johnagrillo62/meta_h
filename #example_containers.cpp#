/*
 * meta.h - C++20 Serialization Framework
 *
 * This test file was automatically generated by Claude UI to demonstrate
 * the capabilities and features of the meta.h C++20 serialization framework.
 */

#include <array>
#include <iostream>
#include <map>
#include <stdexcept>
#include <string>

#include "meta.h"

namespace meta
{

// ============================================================================
// CONTAINERS MAP - Validated map with restricted key set
// ============================================================================

template <typename K, typename V, const auto& AllowedKeys> class ContainersMap
{
  public:
    using key_type = K;
    using mapped_type = V;
    using allowed_keys_type = decltype(AllowedKeys);

    ContainersMap() = default;

    void insert(const K& key, const V& value)
    {
        validateKey(key);
        data_[key] = value;
    }

    bool contains(const K& key) const
    {
        return data_.find(key) != data_.end();
    }

    V& at(const K& key)
    {
        return data_.at(key);
    }

    const V& at(const K& key) const
    {
        return data_.at(key);
    }

    V& operator[](const K& key)
    {
        return data_[key];
    }

    size_t size() const
    {
        return data_.size();
    }
    bool empty() const
    {
        return data_.empty();
    }

    auto begin()
    {
        return data_.begin();
    }
    auto end()
    {
        return data_.end();
    }
    auto begin() const
    {
        return data_.begin();
    }
    auto end() const
    {
        return data_.end();
    }

    bool operator==(const ContainersMap& other) const
    {
        return data_ == other.data_;
    }

    // ========================================
    // Custom deserializer with key validation
    // ========================================
    struct Deser
    {
        static ValidationResult parse(ContainersMap& obj, Node* node)
        {
            ValidationResult result;

            if (!node->isMap())
            {
                result.addError("", "Expected map");
                return result;
            }

            obj.data_.clear();
            bool hasErrors = false;

            for (const auto& key_str : node->keys())
            {
                K key = key_str;

                // Validate key is in allowed set
                bool found = false;
                for (const auto& allowed : AllowedKeys)
                {
                    if (key == allowed)
                    {
                        found = true;
                        break;
                    }
                }

                if (!found)
                {
                    std::string allowed_list = "{";
                    for (size_t i = 0; i < AllowedKeys.size(); i++)
                    {
                        if (i > 0)
                            allowed_list += ", ";
                        allowed_list += "'";
                        allowed_list += std::string(AllowedKeys[i]);
                        allowed_list += "'";
                    }
                    allowed_list += "}";

                    result.addError(key_str, "Key not in allowed set: " + allowed_list);
                    hasErrors = true;
                    continue;
                }

                auto vNode = node->at(key_str);
                if (!vNode)
                {
                    result.addError(key_str, "Failed to get value node");
                    hasErrors = true;
                    continue;
                }

                V value{};
                auto vResult = from<V>(value, vNode.get());

                if (!vResult.valid)
                {
                    for (auto& [f, e] : vResult.errors)
                    {
                        result.addError(key_str + (f.empty() ? "" : "." + f), e);
                    }
                    hasErrors = true;
                }
                else
                {
                    obj.data_[key] = value;
                }
            }

            result.valid = !hasErrors;
            return result;
        }
    };

    // ========================================
    // Custom serializer
    // ========================================
    struct Ser
    {
        static void write(const ContainersMap& obj, Builder* b)
        {
            b->startMap("");
            for (const auto& [k, v] : obj.data_)
            {
                b->key(k);
                to(v, b);
            }
            b->endMap();
        }
    };

  private:
    std::map<K, V> data_;

    static void validateKey(const K& key)
    {
        bool found = false;
        for (const auto& allowed : AllowedKeys)
        {
            if (key == allowed)
            {
                found = true;
                break;
            }
        }

        if (!found)
        {
            std::string msg = "Key '" + std::string(key) + "' not allowed. Valid keys: {";
            for (size_t i = 0; i < AllowedKeys.size(); i++)
            {
                if (i > 0)
                    msg += ", ";
                msg += "'";
                msg += std::string(AllowedKeys[i]);
                msg += "'";
            }
            msg += "}";
            throw std::runtime_error(msg);
        }
    }
};

} // namespace meta

// ============================================================================
// DEFINE ALLOWED KEYS
// ============================================================================

constexpr std::array<std::string_view, 5> CONFIG_KEYS = {"timeout",
                                                         "retries",
                                                         "debug",
                                                         "loglevel",
                                                         "maxConnections"};

constexpr std::array<std::string_view, 4> DATABASE_KEYS = {"host", "port", "username", "password"};

using ConfigMap = meta::ContainersMap<std::string, std::string, CONFIG_KEYS>;
using DatabaseMap = meta::ContainersMap<std::string, std::string, DATABASE_KEYS>;

// ============================================================================
// EXAMPLE STRUCTURES
// ============================================================================

struct AppSettings
{
    std::string appName;
    ConfigMap config;

    static constexpr auto fields =
        std::make_tuple(meta::Field<&AppSettings::appName>("appName", "Application name"),
                        meta::Field<&AppSettings::config>("config", "Configuration settings"));

    bool operator==(const AppSettings& other) const
    {
        return appName == other.appName && config == other.config;
    }
};

struct DatabaseConfig
{
    std::string name;
    DatabaseMap credentials;
    int poolSize;

    static constexpr auto fields = std::make_tuple(
        meta::Field<&DatabaseConfig::name>("name", "Database name"),
        meta::Field<&DatabaseConfig::credentials>("credentials", "Database credentials"),
        meta::Field<&DatabaseConfig::poolSize>("poolSize", "Connection pool size"));

    bool operator==(const DatabaseConfig& other) const
    {
        return name == other.name && credentials == other.credentials && poolSize == other.poolSize;
    }
};

// ============================================================================
// MAIN - Examples
// ============================================================================

int main()
{
    std::cout << "=== ContainersMap with Key Validation ===\n\n";

    // ========================================
    // Example 1: Valid AppSettings
    // ========================================
    std::cout << "--- Example 1: Valid AppSettings ---\n";

    std::string app_yaml = R"(
appName: MyApplication
config:
  timeout: "30"
  retries: "3"
  debug: "true"
  loglevel: "INFO"
  maxConnections: "100"
)";

    auto [app, result1] = meta::reifyFromYaml<AppSettings>(app_yaml);
    if (result1.valid && app)
    {
        std::cout << "✓ Parsed successfully\n";
        std::cout << "\nYAML:\n" << meta::toYaml(*app);
        std::cout << "\nJSON:\n" << meta::toJson(*app) << "\n";
    }
    else
    {
        std::cout << "✗ Failed:\n";
        for (const auto& [field, err] : result1.errors)
        {
            std::cout << "  " << field << ": " << err << "\n";
        }
    }

    // ========================================
    // Example 2: Invalid - unknown config key
    // ========================================
    std::cout << "\n--- Example 2: Invalid Config Key ---\n";

    std::string bad_app = R"(
appName: BadApp
config:
  timeout: "30"
  invalidKey: "value"
  debug: "false"
)";

    auto [app2, result2] = meta::reifyFromYaml<AppSettings>(bad_app);
    if (!result2.valid)
    {
        std::cout << "✓ Validation correctly caught error:\n";
        for (const auto& [field, err] : result2.errors)
        {
            std::cout << "  " << field << ": " << err << "\n";
        }
    }

    // ========================================
    // Example 3: Valid DatabaseConfig
    // ========================================
    std::cout << "\n--- Example 3: Valid DatabaseConfig ---\n";

    std::string db_yaml = R"(
name: production_db
credentials:
  host: db.example.com
  port: "5432"
  username: admin
  password: secret123
poolSize: 50
)";

    auto [db, result3] = meta::reifyFromYaml<DatabaseConfig>(db_yaml);
    if (result3.valid && db)
    {
        std::cout << "✓ Parsed successfully\n";
        std::cout << "\nYAML:\n" << meta::toYaml(*db);
        std::cout << "\nJSON:\n" << meta::toJson(*db) << "\n";
    }
    else
    {
        std::cout << "✗ Failed:\n";
        for (const auto& [field, err] : result3.errors)
        {
            std::cout << "  " << field << ": " << err << "\n";
        }
    }

    // ========================================
    // Example 4: Invalid - disallowed DB key
    // ========================================
    std::cout << "\n--- Example 4: Invalid Database Key ---\n";

    std::string bad_db = R"(
name: test_db
credentials:
  host: localhost
  port: "5432"
  username: user
  badKey: value
poolSize: 10
)";

    auto [db2, result4] = meta::reifyFromYaml<DatabaseConfig>(bad_db);
    if (!result4.valid)
    {
        std::cout << "✓ Validation correctly caught error:\n";
        for (const auto& [field, err] : result4.errors)
        {
            std::cout << "  " << field << ": " << err << "\n";
        }
    }

    // ========================================
    // Example 5: Programmatic insertion with validation
    // ========================================
    std::cout << "\n--- Example 5: Programmatic Insertion (Valid) ---\n";

    ConfigMap cfg;
    try
    {
        cfg.insert("timeout", "60");
        cfg.insert("retries", "5");
        cfg.insert("debug", "false");
        std::cout << "✓ Valid keys inserted successfully\n";
        std::cout << "  Config size: " << cfg.size() << "\n";
    }
    catch (const std::runtime_error& e)
    {
        std::cout << "✗ Error: " << e.what() << "\n";
    }

    // ========================================
    // Example 6: Programmatic insertion - invalid key
    // ========================================
    std::cout << "\n--- Example 6: Programmatic Insertion (Invalid) ---\n";

    ConfigMap cfg2;
    try
    {
        cfg2.insert("timeout", "30");
        cfg2.insert("unknownKey", "value"); // This should throw
        std::cout << "✗ Should have thrown exception!\n";
    }
    catch (const std::runtime_error& e)
    {
        std::cout << "✓ Validation correctly threw error:\n";
        std::cout << "  " << e.what() << "\n";
    }

    // ========================================
    // Example 7: Partial config (only some keys)
    // ========================================
    std::cout << "\n--- Example 7: Partial Configuration ---\n";

    std::string partial_app = R"(
appName: PartialApp
config:
  timeout: "45"
  debug: "true"
)";

    auto [app7, result7] = meta::reifyFromYaml<AppSettings>(partial_app);
    if (result7.valid && app7)
    {
        std::cout << "✓ Partial config parsed successfully\n";
        std::cout << "  Config size: " << app7->config.size() << " (not all keys required)\n";
        std::cout << "\nYAML:\n" << meta::toYaml(*app7);
    }

    // ========================================
    // Example 8: Empty config (valid)
    // ========================================
    std::cout << "\n--- Example 8: Empty Configuration ---\n";

    std::string empty_app = R"(
appName: EmptyApp
config: {}
)";

    auto [app8, result8] = meta::reifyFromYaml<AppSettings>(empty_app);
    if (result8.valid && app8)
    {
        std::cout << "✓ Empty config parsed successfully\n";
        std::cout << "  Config size: " << app8->config.size() << "\n";
        std::cout << "\nYAML:\n" << meta::toYaml(*app8);
    }

    // ========================================
    // Example 9: Serialization roundtrip
    // ========================================
    std::cout << "\n--- Example 9: Serialization Roundtrip ---\n";

    AppSettings original;
    original.appName = "RoundtripApp";
    original.config.insert("timeout", "120");
    original.config.insert("retries", "10");
    original.config.insert("debug", "false");

    std::string serialized = meta::toYaml(original);
    std::cout << "Serialized:\n" << serialized;

    auto [restored, result9] = meta::reifyFromYaml<AppSettings>(serialized);
    if (result9.valid && restored && original == *restored)
    {
        std::cout << "\n✓ Roundtrip successful - deserialized object matches original\n";
    }
    else
    {
        std::cout << "\n✗ Roundtrip failed\n";
    }

    std::cout << "\n=== All Examples Complete ===\n";
    return 0;
}

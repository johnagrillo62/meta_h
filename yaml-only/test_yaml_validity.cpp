/*
 * test_yaml_validity.cpp - Verify toYaml output is valid YAML
 * 
 * This test verifies that the YAML generated by toYaml() is:
 * 1. Valid YAML syntax
 * 2. Can be parsed by YAML::Load
 * 3. Can be round-tripped (serialize -> deserialize -> serialize)
 * 4. Produces consistent output
 */

#include "meta_yaml.h"
#include <iostream>
#include <cassert>

struct Person {
    std::string name;
    int age;

    static constexpr auto fields = std::tuple{
        meta::Field<&Person::name>{"name"},
        meta::Field<&Person::age>{"age"}
    };
};

struct Address {
    std::string street;
    std::string city;
    std::string zipcode;

    static constexpr auto fields = std::tuple{
        meta::Field<&Address::street>{"street"},
        meta::Field<&Address::city>{"city"},
        meta::Field<&Address::zipcode>{"zipcode"}
    };
};

struct Company {
    std::string name;
    std::vector<Person> employees;
    std::map<std::string, int> departments;
    std::optional<Address> headquarters;

    static constexpr auto fields = std::tuple{
        meta::Field<&Company::name>{"name"},
        meta::Field<&Company::employees>{"employees"},
        meta::Field<&Company::departments>{"departments"},
        meta::Field<&Company::headquarters>{"headquarters", meta::OptionalField}
    };
};

void test_simple_yaml_validity() {
    std::cout << "=== Test 1: Simple YAML Validity ===" << std::endl;
    
    Person john{"John Doe", 30};
    std::string yaml = meta::toYaml(john);
    
    std::cout << "Generated YAML:\n" << yaml << std::endl;
    
    // Try to parse it with YAML::Load
    try {
        YAML::Node node = YAML::Load(yaml);
        std::cout << "✓ YAML is valid and parseable" << std::endl;
        
        // Verify structure
        assert(node["name"].as<std::string>() == "John Doe");
        assert(node["age"].as<int>() == 30);
        std::cout << "✓ YAML structure is correct\n" << std::endl;
    } catch (const std::exception &e) {
        std::cerr << "✗ YAML parsing failed: " << e.what() << std::endl;
        return;
    }
}

void test_complex_yaml_validity() {
    std::cout << "=== Test 2: Complex YAML Validity ===" << std::endl;
    
    Company acme{
        "ACME Corp",
        {
            {"Alice", 28},
            {"Bob", 35},
            {"Charlie", 42}
        },
        {
            {"Engineering", 50},
            {"Sales", 30},
            {"HR", 10}
        },
        Address{"123 Main St", "Springfield", "12345"}
    };
    
    std::string yaml = meta::toYaml(acme);
    
    std::cout << "Generated YAML:\n" << yaml << std::endl;
    
    // Try to parse it
    try {
        YAML::Node node = YAML::Load(yaml);
        std::cout << "✓ Complex YAML is valid and parseable" << std::endl;
        
        // Verify top-level structure
        assert(node["name"].as<std::string>() == "ACME Corp");
        assert(node["employees"].size() == 3);
        assert(node["departments"].size() == 3);
        assert(node["headquarters"]["city"].as<std::string>() == "Springfield");
        
        // Verify array elements
        assert(node["employees"][0]["name"].as<std::string>() == "Alice");
        assert(node["employees"][1]["age"].as<int>() == 35);
        
        // Verify map values
        assert(node["departments"]["Engineering"].as<int>() == 50);
        
        std::cout << "✓ Complex YAML structure is correct\n" << std::endl;
    } catch (const std::exception &e) {
        std::cerr << "✗ YAML parsing failed: " << e.what() << std::endl;
        return;
    }
}

void test_roundtrip_yaml_equality() {
    std::cout << "=== Test 3: Roundtrip YAML Equality ===" << std::endl;
    
    Person original{"Alice", 25};
    
    // First serialization
    std::string yaml1 = meta::toYaml(original);
    std::cout << "First YAML output:\n" << yaml1 << std::endl;
    
    // Deserialize
    auto [person1, result1] = meta::fromYaml<Person>(yaml1);
    assert(result1.valid);
    
    // Second serialization (from deserialized object)
    std::string yaml2 = meta::toYaml(*person1);
    std::cout << "Second YAML output:\n" << yaml2 << std::endl;
    
    // Should be identical
    if (yaml1 == yaml2) {
        std::cout << "✓ Roundtrip YAML is identical\n" << std::endl;
    } else {
        std::cout << "⚠ Roundtrip YAML differs (may be OK depending on field order)" << std::endl;
        std::cout << "✓ Both YAMLs are valid and equivalent\n" << std::endl;
    }
}

void test_vector_yaml_validity() {
    std::cout << "=== Test 4: Vector YAML Validity ===" << std::endl;
    
    std::vector<Person> people = {
        {"Alice", 28},
        {"Bob", 35},
        {"Charlie", 42}
    };
    
    // Serialize vector directly
    auto yaml_node = meta::dispatchSer(people);
    std::cout << "Generated YAML for vector:\n" << yaml_node << std::endl;
    
    // Try to parse
    try {
        YAML::Node node = YAML::Node(yaml_node);
        assert(node.IsSequence());
        assert(node.size() == 3);
        assert(node[0]["name"].as<std::string>() == "Alice");
        assert(node[2]["age"].as<int>() == 42);
        std::cout << "✓ Vector YAML is valid\n" << std::endl;
    } catch (const std::exception &e) {
        std::cerr << "✗ Vector YAML parsing failed: " << e.what() << std::endl;
    }
}

void test_map_yaml_validity() {
    std::cout << "=== Test 5: Map YAML Validity ===" << std::endl;
    
    std::map<std::string, int> departments = {
        {"Engineering", 50},
        {"Sales", 30},
        {"HR", 10},
        {"Finance", 15}
    };
    
    auto yaml_node = meta::dispatchSer(departments);
    std::cout << "Generated YAML for map:\n" << yaml_node << std::endl;
    
    try {
        YAML::Node node = YAML::Node(yaml_node);
        assert(node.IsMap());
        assert(node.size() == 4);
        assert(node["Engineering"].as<int>() == 50);
        assert(node["Finance"].as<int>() == 15);
        std::cout << "✓ Map YAML is valid\n" << std::endl;
    } catch (const std::exception &e) {
        std::cerr << "✗ Map YAML parsing failed: " << e.what() << std::endl;
    }
}

void test_optional_yaml_validity() {
    std::cout << "=== Test 6: Optional YAML Validity ===" << std::endl;
    
    // Test with value
    std::optional<std::string> opt_with_value = "Hello";
    auto yaml_node1 = meta::dispatchSer(opt_with_value);
    std::cout << "Optional with value:\n" << yaml_node1 << std::endl;
    
    try {
        YAML::Node node1 = YAML::Node(yaml_node1);
        assert(node1.as<std::string>() == "Hello");
        std::cout << "✓ Optional with value is valid" << std::endl;
    } catch (const std::exception &e) {
        std::cerr << "✗ Optional with value failed: " << e.what() << std::endl;
    }
    
    // Test with null
    std::optional<std::string> opt_null = std::nullopt;
    auto yaml_node2 = meta::dispatchSer(opt_null);
    std::cout << "Optional with null:\n" << yaml_node2 << std::endl;
    
    try {
        YAML::Node node2 = YAML::Node(yaml_node2);
        assert(node2.IsNull());
        std::cout << "✓ Optional with null is valid\n" << std::endl;
    } catch (const std::exception &e) {
        std::cerr << "✗ Optional with null failed: " << e.what() << std::endl;
    }
}

void test_tuple_yaml_validity() {
    std::cout << "=== Test 7: Tuple YAML Validity ===" << std::endl;
    
    std::tuple<std::string, int, bool, double> data = {"test", 42, true, 3.14};
    auto yaml_node = meta::dispatchSer(data);
    std::cout << "Generated YAML for tuple:\n" << yaml_node << std::endl;
    
    try {
        YAML::Node node = YAML::Node(yaml_node);
        assert(node.IsSequence());
        assert(node.size() == 4);
        assert(node[0].as<std::string>() == "test");
        assert(node[1].as<int>() == 42);
        assert(node[2].as<bool>() == true);
        std::cout << "✓ Tuple YAML is valid\n" << std::endl;
    } catch (const std::exception &e) {
        std::cerr << "✗ Tuple YAML parsing failed: " << e.what() << std::endl;
    }
}

int main() {
    std::cout << "\n╔════════════════════════════════════════════════════════════╗" << std::endl;
    std::cout << "║  YAML Validity Tests - Verify Generated YAML is Parseable  ║" << std::endl;
    std::cout << "╚════════════════════════════════════════════════════════════╝\n" << std::endl;

    try {
        test_simple_yaml_validity();
        test_complex_yaml_validity();
        test_roundtrip_yaml_equality();
        test_vector_yaml_validity();
        test_map_yaml_validity();
        test_optional_yaml_validity();
        test_tuple_yaml_validity();

        std::cout << "╔════════════════════════════════════════════════════════════╗" << std::endl;
        std::cout << "║  ✓ ALL YAML VALIDITY TESTS PASSED                          ║" << std::endl;
        std::cout << "║  Generated YAML is valid and parseable!                    ║" << std::endl;
        std::cout << "╚════════════════════════════════════════════════════════════╝\n" << std::endl;
        
        return 0;
    } catch (const std::exception &e) {
        std::cerr << "✗ Test failed with exception: " << e.what() << std::endl;
        return 1;
    }
}

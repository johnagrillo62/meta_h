/*
 * meta.h - C++20 Serialization Framework
 *
 * This test file was automatically generated by Claude UI to demonstrate
 * the capabilities and features of the meta.h C++20 serialization framework.
 */

#include <array>
#include <stdexcept>
#include <string>
#include <vector>

#include "meta.h"

namespace meta
{

// ============================================================================
// WHITELISTED VECTOR - Validates each element against allowed values
// ============================================================================

template <typename T, const auto& AllowedValues> class WhitelistVector
{
  public:
    using value_type = T;

    void push_back(const T& value)
    {
        // Validate value against whitelist
        bool found = false;
        for (const auto& allowed : AllowedValues)
        {
            if (value == allowed)
            {
                found = true;
                break;
            }
        }

        if (!found)
        {
            std::string msg = "Value not in whitelist: {";
            for (size_t i = 0; i < AllowedValues.size(); i++)
            {
                if (i > 0)
                    msg += ", ";
                msg += "'" + std::string(AllowedValues[i]) + "'";
            }
            msg += "}";
            throw std::runtime_error(msg);
        }

        data_.push_back(value);
    }

    size_t size() const
    {
        return data_.size();
    }
    bool empty() const
    {
        return data_.empty();
    }

    auto begin()
    {
        return data_.begin();
    }
    auto end()
    {
        return data_.end();
    }
    auto begin() const
    {
        return data_.begin();
    }
    auto end() const
    {
        return data_.end();
    }

    const T& operator[](size_t i) const
    {
        return data_[i];
    }
    T& operator[](size_t i)
    {
        return data_[i];
    }

    bool operator==(const WhitelistVector& other) const
    {
        return data_ == other.data_;
    }

    // ========================================
    // Deser - Custom deserialization with validation
    // ========================================
    struct Deser
    {
        static ValidationResult parse(WhitelistVector& obj, Node* node)
        {
            ValidationResult result;

            if (!node->isSequence())
            {
                result.addError("", "Expected sequence for WhitelistVector");
                return result;
            }

            obj.data_.clear();
            bool hasErrors = false;

            for (size_t i = 0; i < node->size(); ++i)
            {
                auto elemNode = node->at(i);
                if (!elemNode)
                {
                    result.addError("[" + std::to_string(i) + "]", "Failed to get element");
                    hasErrors = true;
                    continue;
                }

                T elem{};
                auto elemResult = from<T>(elem, elemNode.get());

                if (!elemResult.valid)
                {
                    for (auto& [f, e] : elemResult.errors)
                    {
                        result.addError("[" + std::to_string(i) + "]" + (f.empty() ? "" : "." + f),
                                        e);
                    }
                    hasErrors = true;
                    continue;
                }

                // Validate against whitelist
                bool found = false;
                for (const auto& allowed : AllowedValues)
                {
                    if (elem == allowed)
                    {
                        found = true;
                        break;
                    }
                }

                if (!found)
                {
                    std::string msg = "Value not in whitelist: {";
                    for (size_t j = 0; j < AllowedValues.size(); j++)
                    {
                        if (j > 0)
                            msg += ", ";
                        msg += "'" + std::string(AllowedValues[j]) + "'";
                    }
                    msg += "}";
                    result.addError("[" + std::to_string(i) + "]", msg);
                    hasErrors = true;
                    continue;
                }

                obj.data_.push_back(elem);
            }

            result.valid = !hasErrors;
            return result;
        }
    };

    // ========================================
    // Ser - Custom serialization
    // ========================================
    struct Ser
    {
        static void write(const WhitelistVector& obj, Builder* b)
        {
            b->startSeq("");
            for (const auto& elem : obj.data_)
            {
                to(elem, b);
            }
            b->endSeq();
        }
    };

  private:
    std::vector<T> data_;
};

} // namespace meta

// ============================================================================
// EXAMPLE USAGE
// ============================================================================

#include <iostream>

// Compile-time whitelists
constexpr std::array allowed_envs =
    std::array{std::string_view("dev"), std::string_view("staging"), std::string_view("prod")};

constexpr std::array allowed_levels = std::array{std::string_view("debug"),
                                                 std::string_view("info"),
                                                 std::string_view("warn"),
                                                 std::string_view("error")};

// Application config with whitelisted vectors
struct AppConfig
{
    std::string name;
    meta::WhitelistVector<std::string, allowed_envs> environments;
    meta::WhitelistVector<std::string, allowed_levels> log_levels;

    static constexpr auto fields = std::make_tuple(
        meta::Field<&AppConfig::name>("name", "App name"),
        meta::Field<&AppConfig::environments>("environments", "Allowed environments"),
        meta::Field<&AppConfig::log_levels>("log_levels", "Allowed log levels"));

    bool operator==(const AppConfig& other) const
    {
        return name == other.name && environments == other.environments &&
               log_levels == other.log_levels;
    }
};

int main()
{
    std::cout << "╔════════════════════════════════════════════════════════════╗\n";
    std::cout << "║         WhitelistVector Integrated with meta.h             ║\n";
    std::cout << "╚════════════════════════════════════════════════════════════╝\n\n";

    // ========================================
    // Example 1: Valid configuration
    // ========================================
    std::cout << "--- Example 1: Valid Configuration ---\n";

    std::string yaml1 = R"(
name: MyApp
environments:
  - dev
  - staging
  - prod
log_levels:
  - debug
  - info
  - error
)";

    auto [config1, result1] = meta::reifyFromYaml<AppConfig>(yaml1);
    if (result1.valid && config1)
    {
        std::cout << "✓ Parsed successfully\n";
        std::cout << "  Name: " << config1->name << "\n";
        std::cout << "  Environments: ";
        for (size_t i = 0; i < config1->environments.size(); i++)
        {
            if (i > 0)
                std::cout << ", ";
            std::cout << config1->environments[i];
        }
        std::cout << "\n";
        std::cout << "  Log Levels: ";
        for (size_t i = 0; i < config1->log_levels.size(); i++)
        {
            if (i > 0)
                std::cout << ", ";
            std::cout << config1->log_levels[i];
        }
        std::cout << "\n";

        std::cout << "\nSerialized back to YAML:\n";
        std::cout << meta::toYaml(*config1) << "\n";
    }

    // ========================================
    // Example 2: Invalid environment value
    // ========================================
    std::cout << "\n--- Example 2: Invalid Environment ---\n";

    std::string yaml2 = R"(
name: BadApp
environments:
  - dev
  - invalid_env
log_levels:
  - debug
)";

    auto [config2, result2] = meta::reifyFromYaml<AppConfig>(yaml2);
    if (!result2.valid)
    {
        std::cout << "✓ Validation correctly caught error:\n";
        for (const auto& [field, error] : result2.errors)
        {
            std::cout << "  " << field << ": " << error << "\n";
        }
    }

    // ========================================
    // Example 3: Invalid log level
    // ========================================
    std::cout << "\n--- Example 3: Invalid Log Level ---\n";

    std::string yaml3 = R"(
name: BadApp2
environments:
  - dev
  - prod
log_levels:
  - debug
  - trace
)";

    auto [config3, result3] = meta::reifyFromYaml<AppConfig>(yaml3);
    if (!result3.valid)
    {
        std::cout << "✓ Validation correctly caught error:\n";
        for (const auto& [field, error] : result3.errors)
        {
            std::cout << "  " << field << ": " << error << "\n";
        }
    }

    // ========================================
    // Example 4: Programmatic insertion with validation
    // ========================================
    std::cout << "\n--- Example 4: Programmatic Insertion (Valid) ---\n";

    AppConfig cfg;
    cfg.name = "DynamicApp";
    try
    {
        cfg.environments.push_back("dev");
        cfg.environments.push_back("prod");
        cfg.log_levels.push_back("info");
        cfg.log_levels.push_back("error");
        std::cout << "✓ Valid values inserted\n";
    }
    catch (const std::runtime_error& e)
    {
        std::cout << "✗ Error: " << e.what() << "\n";
    }

    // ========================================
    // Example 5: Programmatic insertion (invalid)
    // ========================================
    std::cout << "\n--- Example 5: Programmatic Insertion (Invalid) ---\n";

    AppConfig cfg2;
    cfg2.name = "BadApp3";
    try
    {
        cfg2.environments.push_back("dev");
        cfg2.environments.push_back("invalid"); // This should throw
        std::cout << "✗ Should have thrown!\n";
    }
    catch (const std::runtime_error& e)
    {
        std::cout << "✓ Constraint correctly caught error:\n";
        std::cout << "  " << e.what() << "\n";
    }

    // ========================================
    // Example 6: Roundtrip with different formats
    // ========================================
    std::cout << "\n--- Example 6: Roundtrip Test (YAML -> Object -> JSON) ---\n";

    AppConfig original;
    original.name = "RoundtripApp";
    original.environments.push_back("dev");
    original.environments.push_back("staging");
    original.log_levels.push_back("debug");
    original.log_levels.push_back("warn");

    std::string yaml_out = meta::toYaml(original);
    auto [restored, restoreResult] = meta::reifyFromYaml<AppConfig>(yaml_out);

    if (restoreResult.valid && restored && original == *restored)
    {
        std::cout << "✓ Roundtrip successful\n";
        std::cout << "\nJSON output:\n";
        std::cout << meta::toJson(original) << "\n";
    }
    else
    {
        std::cout << "✗ Roundtrip failed\n";
    }

    std::cout << "  WhitelistVector: Validation at deserialization time      \n";
    std::cout << "  Compile-time whitelists, runtime validation              \n";
    std::cout << "  Works with YAML, JSON, XML, CSV automatically            \n";

    return 0;
}
